---
title: "Target enrichment evaluation from a Cas9-based workflow"
date: "Report created: `r Sys.Date()`"
output:
  html_document:
    keep_md: yes
    number_sections: yes
    self_contained: yes
    theme: default
    highlight: null
    css: Static/ont_tutorial.css
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: yes
      smooth_scroll: yes
    df_print: paged
link-citations: yes
bibliography: Static/Bibliography.bib
always_allow_html: yes
---

<div style="position:absolute;top:0px;right:0px;padding:15px;background-color:gray;width:45%;">
```{r, echo=FALSE, eval=FALSE}
knitr::include_graphics("https://nanoporetech.com/themes/custom/nanopore/images/ont-logo.svg?tutorial=cas9enrichment")
```
</div>


```{r setup, include=FALSE}
knitr::opts_chunk$set(tidy=TRUE, tidy.opts=list(width.cutoff=80), 
                      fig.width=9, fig.height=6, warning=FALSE, message=FALSE, 
                      kable.force.latex=TRUE,
                      highlight=TRUE,
                      cache.path="Analysis/Cache/",
                      knitr.table.format = "html",
                      width = 120,
                      knitr.kable.NA = '')

options(knitr.kable.NA = '')

library(yaml)
library(session)
library(kableExtra)
library(ggplot2)
library(RColorBrewer)
library(scales) # required for comma
library(reshape2)
library(parallel)
library(GenomicAlignments)
library(dplyr)
library(emojifont)
library(ggbio)

config <- yaml.load_file("config.yaml")
bed_src <- config$target_regions
study <- config$study_name
reference <- config$reference_genome
target_proximity <- as.integer(config$target_proximity)
offtarget_level <- as.integer(config$offtarget_level)
tutorialText   <- config$tutorialText

### here lie dragons ###
# expeditions below this comment at your own risk
# welcome feedback and suggestions ...

slurpContent <- function(filename) {
  include = as.logical(tutorialText)
  if (include) {
    paste(readLines(filename),collapse="\n")
  }
}

reportDPI <- 90
```


`r slurpContent("Static/TutorialPreamble.md")`

```{r, echo=FALSE}
r_results <- file.path("Analysis","R")
# if r_results does not exist the snakemake either failed or has not run -- flag a warning?
```


```{r, echo=FALSE}
# load the general mapping results and analysis ...
mappingResultsFile <- file.path(r_results, paste0(study, "_mapping_results", ".Rdata"))
load(mappingResultsFile)

# load the aggregated coverage file - used for plotting coverage at finer resolution for the pre-defined targets
aggregatedCovFile <- file.path(r_results, paste0(study, "_aggregated_coverage", ".Rdata"))
load(aggregatedCovFile)

# load the sequence metadata for the unmapped sequence reads
qualfilelocation = file.path("Analysis","Minimap2", paste0(study, ".unmapped.quals"))
chromosomeFile <- file.path(r_results, paste(sub("\\.[^.]*$", "", basename(qualfilelocation)), "rcounts", "Rdata",sep="."))
unmappedReads <- readRDS(file=chromosomeFile)

phredmean <- function(l) {
  -10 * log10(mean(10^(l/-10)))
}
```






The first step for the analysis of the Cas9 enrichment strategy is to assess the coverage of sequence reads across the whole genome. The **`BAM`** file produced by mapping the sequence reads to the reference genome using **`Minimap2`** is assessed for this purpose. The genome is broken into three slices. These slices correspond to 

* The **`On Target`** regions that are defined as regions of interest in the provided **`BED`** format coordinate file (*`r bed_src`*)
* The **`Target Flanking`** regions that are immediately upstream or downstream of an On Target region (this regions is defined as `r as.integer(target_proximity)` bases)
* The **`Background`** regions of the genome have a stochastic coverage
* The **`Off Target`** regions are defined as the subset of the background genome that has a depth-of-coverage of > **`r as.integer(config$offtarget_level)`**.

Target regions are calculated using the genome coordinates from the provided reference genome (`r basename(reference)`) and the **R** **`GenomicRanges`** package is used to select for the coordinates that correspond to OnTarget, TargetFlanking and OffTarget regions. The genome reference sequence and mapped reads are assessed for a number of metrics that could be used to assess the performance of the target capture. This BAM parsing analysis utilises both the **`GenomicRanges`** coordinate handling package and the **`Rsamtools`** package for the parsing and exploration of BAM files.


# Executive Summary


```{r seqInfoPlot, include=TRUE, echo=FALSE, fig.fullwidth = TRUE, dpi=360, fig.width=9, fig.height=2}

figures <- 4

cas9Throughput <- sum(backgroundUniverse$basesstart) + sum(unmappedReads$width) + 
  sum(offtargetUniverse$basesstart) + 
  sum(targetproximalUniverse$basesstart) + 
  sum(ontargetUniverse$basesstart)
cas9Throughput <- paste(round(cas9Throughput / 1e9, digits=2), "Gb")
    
#ontargetLabel <- paste(round(sum(ontargetUniverse$basesstart) / (sum(backgroundUniverse$basesstart) + sum(unmappedReads$width) + sum(offtargetUniverse$basesstart) + sum(targetproximalUniverse$basesstart) + sum(ontargetUniverse$basesstart)) * 100, 2), "%")
ontargetLabel <- paste0(round(sum(ontargetUniverse$rstart) / (sum(ontargetUniverse$rstart) + length(unmappedReads) + sum(offtargetUniverse$rstart) + sum(targetproximalUniverse$rstart) + sum(backgroundUniverse$rstart)) * 100, digits=2), "%")
meanCovLabel <- paste0(round(mean(rep(ontargetUniverse$dmean, width(ontargetUniverse))), digits=1), "X")

depletionLabel = paste0(round(Hmisc::wtd.quantile(ontargetUniverse$dmean, probs=c(0.5), weight=width(ontargetUniverse)) / Hmisc::wtd.quantile(as.numeric(backgroundUniverse$dmean), probs=c(0.5), weight=as.numeric(width(backgroundUniverse))), digits=1), " X")

df <- data.frame(
    x = cumsum(c(2, rep(6.5, figures-1))),
    y = rep(2, figures),
    h = rep(4, figures),
    w = rep(6, figures))

    df$info <- c(cas9Throughput, ontargetLabel, meanCovLabel, depletionLabel)
    df$key <- c("Throughput", "reads on target", "mean target coverage", "non-target depletion")
    df$icon <- fontawesome(c("fa-calculator", "fa-cut", "fa-map", "fa-code-fork"))

    df$colour <- rep("steelblue", figures)

ReadCharacteristicsValueBoxes <- ggplot(df, aes(x, y, height = h, width = w, label = key, fill = colour)) +
    geom_tile(fill = brewer.pal(9,"Blues")[7]) +
    geom_text(color = brewer.pal(9,"Blues")[3], hjust="left", nudge_y=-1.5, nudge_x=-2.6, size=3.5) +
    geom_text(label=df$icon, family='fontawesome-webfont', colour=brewer.pal(9,"Blues")[5], size=14, hjust="right", nudge_x=2.85, nudge_y=0.9) +
    geom_text(label=df$info, size=9, color = brewer.pal(9,"Blues")[2], fontface = "bold", nudge_x=-2.6, hjust="left") +
    coord_fixed() + 
    scale_fill_brewer(type = "qual",palette = "Dark2") +
    theme_void() +
    guides(fill = F)



ggplot2::ggsave(file.path(r_results, "EnrichmentValueBoxesA.png"), plot=ReadCharacteristicsValueBoxes, device="png", units="cm", width=25, height=5, dpi=reportDPI)

knitr::include_graphics(file.path(r_results, "EnrichmentValueBoxesA.png"))

```



```{r summaryStatistics, echo=FALSE, results="asis", eval=TRUE}

addRow <- function(df, metric, count, percentage="") {
  return(df %>% add_row(metric=metric, count=count, percentage=percentage))
}

collateMappingCharacteristics <- function(bamFile, unmappedBamFile=NA) {
  suppressWarnings(if (is.na(unmappedBamFile)) { unmappedBamFile <- data.frame(width=numeric(), quality=numeric()) })
  # basic counts for #s of reads
  mappedSeqs <- sum(bamFile$rstart)
  unmappedSq <- nrow(unmappedBamFile)
  totalReads <- mappedSeqs + unmappedSq
  # basic counts for #s of nucleotides
  mappedNts <- sum(bamFile$basesstart)
  unmappedNts <- sum(unmappedBamFile$width)
  fastqNts <- mappedNts + unmappedNts
  mappedClippedNts <- sum(bamFile$cigarmapped)
  
  # reference genome characteristics
  refSize <- paste0(round(sum(as.numeric(width(bamFile))) / effectiveGenomeSize * 100, digits=3),"%")

  meanCov <- sum(bamFile$dmean * width(bamFile), na.rm=TRUE) / sum(width(bamFile), na.rm=TRUE)
  
  summary.df <- data.frame(metric=character(), count=character(), percentage=character(), stringsAsFactors = FALSE)
  summary.df <- addRow(summary.df, "total sequence reads", scales::comma_format()(totalReads))
  summary.df <- addRow(summary.df, "mapped reads (primary)", scales::comma_format()(mappedSeqs))
  summary.df <- addRow(summary.df, "bases sequenced", scales::comma_format()(fastqNts))
  summary.df <- addRow(summary.df, "bases mapped", scales::comma_format()(mappedNts))
  summary.df <- addRow(summary.df, "Fraction of genome (%)", refSize)
  summary.df <- addRow(summary.df, "Mean coverage (primary)", round(meanCov, digits=2))
  
  rownames(summary.df) <- summary.df[,1]
  summary.df <- summary.df[,-1]
  return(summary.df)
}

effectiveGenomeSize <- sum(width(backgroundUniverse)) + sum(width(offtargetUniverse)) + sum(width(targetproximalUniverse)) + sum(width(ontargetUniverse))

summary.df <- as.data.frame(cbind(collateMappingCharacteristics(backgroundUniverse, unmappedReads), 
                    collateMappingCharacteristics(offtargetUniverse),
                    collateMappingCharacteristics(targetproximalUniverse),
                    collateMappingCharacteristics(ontargetUniverse)))

summary.df <- summary.df[,-c(2,4,6,8)]
summary.df[summary.df == "NaN"] <- ""


row.names(summary.df)[1]<- paste0(row.names(summary.df)[1], footnote_marker_symbol(1, "html"))
row.names(summary.df)[2]<- paste0(row.names(summary.df)[2], footnote_marker_symbol(2, "html"))
row.names(summary.df)[6]<- paste0(row.names(summary.df)[6], footnote_marker_symbol(3, "html"))
#row.names(summary.df)[16]<- paste0(row.names(summary.df)[16], footnote_marker_symbol(4, "html"))
#row.names(summary.df)[17]<- paste0(row.names(summary.df)[17], footnote_marker_symbol(5, "html"))

kable(summary.df, format="html", col.names=rep(" ", ncol(summary.df)), caption="Table summarising global mapping characteristics ranked by on-target, target-flanking and off-target", booktabs=TRUE, table.envir='table*', linesep="", escape = FALSE)  %>%
  add_header_above(c(" ", "Background"=1,"Off-Target"=1,"Target-flanking"=1,"On-Target"=1)) %>%
  kable_styling(c("striped", "condensed")) %>%
  footnote(symbol=c("fastq bases are calculated from the qwidth field of the mapped sequences and from the sequence length of unmapped sequences", "this table presents only primary sequence mappings", "depth of coverage based only on primary mapping reads"), symbol_title="please note: ", footnote_as_chunk = TRUE)


```



# Evaluation of reads that map to defined targets

The next step in the analysis involves looking for the mapping characteristics for each of the targets specified within the BAM file. For brevity, only the most salient metrics are reported here (values such as the number of reads, the number of bases and mapping qualities), there are other values within the data (please check the **`brRes`** object).

```{r, echo=FALSE, results="asis", eval=TRUE}
bygene <- cbind(names(ontargetUniverse), scales::comma_format()(width(ontargetUniverse)), round(ontargetUniverse$dmean, digits=2),  scales::comma_format()(ontargetUniverse$rstart), scales::comma_format()(ontargetUniverse$basesstart), scales::comma_format()(round(ontargetUniverse$meanreadlen, digits=2)), round(ontargetUniverse$readq, digits=2), round(ontargetUniverse$mapq, digits=2), round(ontargetUniverse$strandp / ontargetUniverse$rstart*100, digits=2))
colnames(bygene) <- seq(1, ncol(bygene))

colnames(bygene)[1]<- paste0("Target Gene")
colnames(bygene)[2]<- paste0("Target size")
colnames(bygene)[3]<- paste0("Mean coverage")
colnames(bygene)[4]<- paste0("Read count", footnote_marker_symbol(1, "html"))
colnames(bygene)[5]<- paste0("Bases", footnote_marker_symbol(2, "html"))
colnames(bygene)[6]<- paste0("Mean readLength")
colnames(bygene)[7]<- paste0("Mean readQuality")
colnames(bygene)[8]<- paste0("Mean mapQuality")
colnames(bygene)[9]<- paste0("Reads on FWD(%)", footnote_marker_symbol(3, "html"))

kable(bygene, format="html", caption="Table summarising target mapping for pre-defined regions of interest", booktabs=TRUE, table.envir='table*', linesep="", escape = FALSE)  %>%
  kable_styling(c("striped", "condensed")) %>%
  footnote(symbol=c("Reads are counted as all sequence reads where the SAM start location is located within the target interval. This does not correct for sequences on the reverse strand.", "Bases are counted as the sum of nucleotides from all reads where the SAM start location is within target region; some of these bases will overlap the flanking region", "reads are assessed for strand of mapping; here reads on + strand are summarised as percentage of all"), symbol_title="please note: ", footnote_as_chunk = TRUE)

```





```{r targetGeneDepths, echo=FALSE}
colMax=4
suppressWarnings(posMatrix <- matrix(gtools:::mixedsort(names(br)), ncol=colMax, byrow=TRUE))
  # data may be recycled ... remove duplicate values ...
posMatrix[which(duplicated(posMatrix[seq(nrow(posMatrix) * ncol(posMatrix))]))]<-NA

plotLegend <- paste0("t::",gtools:::mixedsort(names(br)))
plotCols <- ceiling(length(plotLegend) / colMax)
legendDF <- data.frame(x=Inf, y=Inf, 
                         lab=plotLegend, 
                         row=unlist(lapply(1:plotCols, rep, times=colMax))[1:length(plotLegend)], 
                         col=rep(seq(1, colMax), length.out=length(plotLegend)))

# add row and column data to aggregatedGR
aggregatedGR$row <- unlist(lapply(aggregatedGR$gene, function(x) { which(posMatrix==x, arr.ind=TRUE)[[1]] }))
aggregatedGR$col <- unlist(lapply(aggregatedGR$gene, function(x) { which(posMatrix==x, arr.ind=TRUE)[[2]] }))
aggregatedGR$rev_cov <- aggregatedGR$binned_cov - aggregatedGR$fwd_cov


singlePlot <- function(geneName, covData, delta=0) {
  delta=min(delta, target_proximity)
  covData <- as.data.frame(covData)
  covData <- covData[which(covData$gene==geneName),]
  offset <- covData[covData$pos==1,]$start
  suppressWarnings(plot <- ggplot(covData)+
    geom_hline(yintercept=(wga.cov * offtarget_level), colour="#E69F00") +
    geom_line(aes(x=start,y=binned_cov), size=0.5, colour=brewer.pal(6, "Paired")[2])+
    xlab(paste("Position on chromosome",unique(covData$seqnames))) + 
    ylab("Depth of Coverage (X)") + 
    labs(title=paste("Plot showing depth of coverage vs position for target", geneName)) + 
    geom_vline(xintercept=(offset+target_proximity), colour="red", alpha=0.4) +
    geom_vline(xintercept=(offset+(max(covData$pos)-target_proximity)), colour="red", alpha=0.4) +
    scale_x_continuous(limits = c(offset+delta, offset+max(covData$pos)-delta))
  )
  return(plot)
}

```


```{r, warning=FALSE}
singlePlot("C9orf72", aggregatedGR)

singlePlot("C9orf72", aggregatedGR, delta=22500)
```



```{r, echo=FALSE}
strandedPlot <- function(geneName, covData, delta=0) {
  delta=min(delta, target_proximity)
  covData <- as.data.frame(covData)
  covData <- covData[which(covData$gene==geneName),]
  offset <- covData[covData$pos==1,]$start
  mdata <- melt(covData[,c("gene", "start", "fwd_cov", "rev_cov")], id.vars=c("gene", "start"))
  suppressWarnings(plot <- ggplot(mdata, aes(start, value)) +
    geom_hline(yintercept=(wga.cov * offtarget_level), colour="#E69F00") +
    geom_area(aes(fill=variable))  +
    xlab(paste("Position on chromosome",unique(covData$seqnames))) + 
    ylab("Depth of Coverage (X)") + 
    labs(title=paste("Plot showing depth of coverage vs position for target", geneName)) + 
    geom_vline(xintercept=(offset+target_proximity), colour="red", alpha=0.4) +
    geom_vline(xintercept=(offset+(max(covData$pos)-target_proximity)), colour="red", alpha=0.4) +
    scale_x_continuous(limits = c(offset+delta, offset+max(covData$pos)-delta)) +
    scale_fill_manual(values=c(brewer.pal(5, "Paired")[1], brewer.pal(5, "Paired")[2]),
                      name="Strand mapped",
                         breaks=c("fwd_cov", "rev_cov"),
                         labels=c("Forward", "Reverse"))
  )
  return(plot)
}
```


```{r, warning=FALSE}
strandedPlot("C9orf72", aggregatedGR, delta=12500)
```





```{r aggregatePlot, echo=FALSE, warning=FALSE}
plotCoverageMegablock <- function(covData) {
  covData$start <- (as.numeric(covData$start))/1000
  suppressWarnings(megadepthplot <- ggplot(covData, aes(pos, binned_cov)) + 
                     geom_hline(yintercept=(wga.cov * offtarget_level), colour="#E69F00") +
                     geom_line(colour=brewer.pal(6, "Paired")[2]) + 
                     facet_grid(rows = vars(row), cols=vars(col)) + theme(axis.text.x = element_text(angle = 90, hjust = 1), strip.text.y = element_blank(), strip.text.x = element_blank()) + xlab("Position across target region (kb)") + ylab("Depth of Coverage (X)") + labs(title="Plot showing depth of coverage vs position for target regions") + geom_text(aes(x,y,label=lab), data=legendDF, vjust=1, hjust=1, size=3.5) + theme(plot.title = element_text(size=11)))
  return(megadepthplot)
}

plotCoverageMegablock(as.data.frame(aggregatedGR))

```



```{r offTargetByDepth, echo=FALSE}

targetMap <- data.frame(chromosome=gtools:::mixedsort(levels(seqnames(backgroundUniverse))), stringsAsFactors=FALSE)
targetMap <- cbind(targetMap, offtarget=unlist(lapply(targetMap$chromosome, function(x) { 
  sum(offtargetUniverse[which(seqnames(offtargetUniverse)==x)]$basesstart) } )))
targetMap <- cbind(targetMap, background=unlist(lapply(targetMap$chromosome, function(x) {   
  sum(backgroundUniverse[which(seqnames(backgroundUniverse)==x)]$basesstart) } )))
targetMap <- cbind(targetMap, ontarget=unlist(lapply(targetMap$chromosome, function(x) {   
  sum(ontargetUniverse[which(seqnames(ontargetUniverse)==x)]$basesstart) } )))
targetMap[is.na(targetMap)] <- 0
#targetMap
targetMelt <- melt(targetMap)
targetMelt$variable <- factor(as.character(targetMelt$variable), c("background", "ontarget", "offtarget"))
targetMelt$chromosome <- factor(targetMelt$chromosome, gtools:::mixedsort(unique(targetMelt$chromosome)))

suppressWarnings(plot <- ggplot(targetMelt, aes(chromosome, value)) + geom_col(aes(fill=variable)) + scale_y_continuous(labels = comma) + ylab("Number of bases (nt)") + labs(title="Barchart showing number of references bases assigned as ontarget,\nofftarget or background") + scale_fill_brewer(direction=-1, palette="Spectral")
)
# coord_cartesian(ylim =c(0,1000000))
```




# Off-target mapping

Having assessed on-target characteristics, it makes sense to also consider what has been mapped to depth within the broader genomic context that does not appear as a clear target.

The **`ideogram`** below presents a description of the off-target mapping. Each shaded region (or bar) corresponds to an off-target region. 


```{r, echo=FALSE, message=FALSE}

seqlevels(offtargetUniverse) <- unique(gtools:::mixedsort(as.character(seqnames(offtargetUniverse))))

autoplot(offtargetUniverse, layout="karyogram")

```




The coordinates for these off-target regions have been written to an accompanying CSV file that may be imported into Excel for further analysis. The top 10 regions, ranked by mean depth-of-coverage, are presented in the table below. 


```{r, echo=FALSE}

offtargtop <- as.data.frame(offtargetUniverse[order(offtargetUniverse$dmean, decreasing=TRUE)[1:10]])[,c(1,2,3,23,6,8,10,14)]
colnames(offtargtop)[1]<-"chrId"
offtargtop$strandp <- round(as.numeric(offtargtop$strandp)/as.numeric(offtargtop$rstart)*100, digits=2)
kable(offtargtop, format="html", caption="Table summarising the location and characteristics for the off-target regions with the highest depth-of-coverage", booktabs=TRUE, table.envir='table*', linesep="", escape = FALSE)  %>%
  kable_styling(c("striped", "condensed")) %>%
  footnote(symbol=c("This table has been prepared using only read mapping information that corresponds to a primary map", "The rstart column describes the number of sequences that start within this genomic interval (using SAM start coordinate only)", "meanreadLen is the mean sequence read length for the rstart genes identified; their strandedness is summarised in strandp (the number of sequences that appear on the forward strand) and the mapping quality is summarised in mapq", "dmean summarised the mean depth of coverage across the sequenced interval"), symbol_title="please note: ", footnote_as_chunk = TRUE)
```



# Reproducible research - produce your own report

This report has been created using **`Rmarkdown`**, publicly available **`R`** packages, and the \LaTeX document typesetting software for reproducibility. For clarity the **`R`** packages used, and their versions, are listed below.

\fontsize{8}{12}

```{r sessionInfo, eval=TRUE, echo=FALSE, comment=NA}
utils:::print.sessionInfo(sessionInfo()[-7], locale=FALSE)
```

\fontsize{10}{14}

It is also worth recording the versions of the software that have been used for the analysis.

\fontsize{8}{12}

```{r, engine='bash', echo=FALSE, comment=NA}
conda list "samtools|minimap2|snakemake|rstudio|seqtk"
```

\fontsize{10}{14}

`r slurpContent("Static/TutorialPostamble.md")`

\pagebreak


# References and citations
