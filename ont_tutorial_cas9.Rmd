---
title: "Target enrichment evaluation from a Cas9-based workflow"
date: "Report created: `r Sys.Date()`"
output:
  html_document:
    keep_md: yes
    number_sections: yes
    self_contained: yes
    theme: default
    highlight: null
    css: Static/ont_tutorial.css
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: yes
      smooth_scroll: yes
    df_print: paged
link-citations: yes
bibliography: Static/Bibliography.bib
always_allow_html: yes
---

<div style="position:absolute;top:0px;right:0px;padding:15px;background-color:gray;width:45%;">
```{r, echo=FALSE}
knitr::include_graphics("https://nanoporetech.com/themes/custom/nanopore/images/ont-logo.svg?tutorial=cas9enrichment")
```
</div>


```{r setup, include=FALSE}
knitr::opts_chunk$set(tidy=TRUE, tidy.opts=list(width.cutoff=80), 
                      fig.width=9, fig.height=6, warning=FALSE, message=FALSE, 
                      kable.force.latex=TRUE,
                      highlight=TRUE,
                      cache.path="Analysis/Cache/",
                      knitr.table.format = "html",
                      width = 120,
                      knitr.kable.NA = '')

options(knitr.kable.NA = '')

library(yaml)
library(session)
library(kableExtra)
library(ggplot2)
library(RColorBrewer)
library(scales) # required for comma
library(reshape2)
library(parallel)
library(GenomicAlignments)
library(dplyr)

config <- yaml.load_file("config.yaml")
bed_src <- config$target_regions
study <- config$study_name
reference <- config$reference_genome
target_proximity <- as.integer(config$target_proximity)
offtarget_level <- as.integer(config$offtarget_level)
tutorialText   <- config$tutorialText

### here lie dragons ###
# expeditions below this comment at your own risk
# welcome feedback and suggestions ...

slurpContent <- function(filename) {
  include = as.logical(tutorialText)
  if (include) {
    paste(readLines(filename),collapse="\n")
  }
}
```


`r slurpContent("Static/TutorialPreamble.md")`

```{r, echo=FALSE}
r_results <- file.path("Analysis","R")
# if r_results does not exist the snakemake either failed or has not run -- flag a warning?
```


```{r, echo=FALSE}
# load the general mapping results and analysis ...
mappingResultsFile <- file.path(r_results, paste0(study, "_mapping_results", ".Rdata"))
load(mappingResultsFile)

# load the aggregated coverage file - used for plotting coverage at finer resolution for the pre-defined targets
aggregatedCovFile <- file.path(r_results, paste0(study, "_aggregated_coverage", ".Rdata"))
load(aggregatedCovFile)

# load the sequence metadata for the unmapped sequence reads
qualfilelocation = file.path("Analysis","Minimap2", paste0(study, ".unmapped.quals"))
chromosomeFile <- file.path(r_results, paste(sub("\\.[^.]*$", "", basename(qualfilelocation)), "rcounts", "Rdata",sep="."))
unmappedReads <- readRDS(file=chromosomeFile)
```






The first step for the analysis of the Cas9 enrichment strategy is to assess the coverage of sequence reads across the whole genome. The **`BAM`** file produced by mapping the sequence reads to the reference genome using **`Minimap2`** is assessed for this purpose. The genome is broken into three slices. These slices correspond to 

* The **`On Target`** regions that are defined as regions of interest in the provided **`BED`** format coordinate file (*`r bed_src`*)
* The **`Target Flanking`** regions that are immediately upstream or downstream of an On Target region (this regions is defined as `r as.integer(target_proximity)` bases)
* The **`Background`** regions of the genome have a stochastic coverage
* The **`Off Target`** regions are defined as the subset of the background genome that has a depth-of-coverage of > **`r as.integer(config$offtarget_level)`**.

Target regions are calculated using the genome coordinates from the provided reference genome (`r basename(reference)`) and the **R** **`GenomicRanges`** package is used to select for the coordinates that correspond to OnTarget, TargetFlanking and OffTarget regions. The genome reference sequence and mapped reads are assessed for a number of metrics that could be used to assess the performance of the target capture. This BAM parsing analysis utilises both the **`GenomicRanges`** coordinate handling package and the **`Rsamtools`** package for the parsing and exploration of BAM files.


```{r summaryStatistics, echo=FALSE, results="asis", eval=TRUE}

addRow <- function(df, metric, count, percentage="") {
  return(df %>% add_row(metric=metric, count=count, percentage=percentage))
}

collateMappingCharacteristics <- function(bamFile, unmappedBamFile=NA) {
  suppressWarnings(if (is.na(unmappedBamFile)) { unmappedBamFile <- data.frame(width=numeric(), quality=numeric()) })
  # basic counts for #s of reads
  mappedSeqs <- sum(bamFile$rstart)
  unmappedSq <- nrow(unmappedBamFile)
  totalReads <- mappedSeqs + unmappedSq
  # basic counts for #s of nucleotides
  mappedNts <- sum(bamFile$basesstart)
  unmappedNts <- sum(unmappedBamFile$width)
  fastqNts <- mappedNts + unmappedNts
  mappedClippedNts <- sum(bamFile$cigarmapped)
  # basic counts for read lengths
  mappedLength <- mean(rep(bamFile$meanreadlen, bamFile$rstart))
  unmappedLength <- mean(unmappedBamFile$width)
  # basic counts for quality scores
  mappedQuality <- mean(rep(bamFile$readq, bamFile$rstart))
  unmappedQuality <- mean(unmappedBamFile$quality)
  
  # mapping details ...
  mismatches <- sum(bamFile$nm)
  insertions <- sum(bamFile$cigarins)
  deletions <- sum(bamFile$cigardel)
  meanMapQ <- mean(bamFile$mapq, na.rm=TRUE)
  
  # reference genome characteristics
  refSize <- sum(width(bamFile))
  Ncount <- sum(bamFile$ncount)/sum(width(bamFile))*100
  GCcount <- sum(bamFile$gccount)/sum(width(bamFile))*100
  chromosomeCount <- length(unique(as.character(seqnames(bamFile))))
  meanCov <- sum(bamFile$dmean * width(bamFile), na.rm=TRUE) / sum(width(bamFile), na.rm=TRUE)

  
  summary.df <- data.frame(metric=character(), count=character(), percentage=character(), stringsAsFactors = FALSE)
  summary.df <- addRow(summary.df, "total sequence reads", scales::comma_format()(totalReads))
  summary.df <- addRow(summary.df, "mapped reads (primary)", scales::comma_format()(mappedSeqs), 
                                       paste(round(mappedSeqs / totalReads * 100, digits=2),"%", sep=""))
  summary.df <- addRow(summary.df, "unmapped reads", scales::comma_format()(unmappedSq), 
                                       paste(round(unmappedSq / totalReads * 100, digits=2),"%", sep=""))
  
  summary.df <- addRow(summary.df, "total fastq nucleotides", scales::comma_format()(fastqNts))
  summary.df <- addRow(summary.df, "sum of nucleotides from mapped reads", scales::comma_format()(mappedNts), 
                                       paste(round(mappedNts / fastqNts * 100, digits=2),"%", sep=""))
  summary.df <- addRow(summary.df, ".....nucleotides from clipped mapping", scales::comma_format()(mappedClippedNts), 
                                       paste(round(mappedClippedNts / fastqNts * 100, digits=2),"%", sep=""))
  summary.df <- addRow(summary.df, "unmapped nucleotides", scales::comma_format()(unmappedNts), 
                                       paste(round(unmappedNts / fastqNts * 100, digits=2),"%", sep=""))
  
  summary.df <- addRow(summary.df, "mean read length (mapped)", scales::comma_format()(mappedLength))
  summary.df <- addRow(summary.df, "mean read length (unmapped)", scales::comma_format()(unmappedLength))
  
  summary.df <- addRow(summary.df, "mean read quality (mapped)", round(mappedQuality, digits=2))
  summary.df <- addRow(summary.df, "mean read quality (unmapped)", round(unmappedQuality, digits=2))
  
  summary.df <- addRow(summary.df, "mean mapping quality (primary)", round(meanMapQ, digits=2))
  
  summary.df <- addRow(summary.df, "Chromosome Count", chromosomeCount)
  summary.df <- addRow(summary.df, "Reference size (nt)", scales::comma_format()(refSize))
  summary.df <- addRow(summary.df, "N count", paste(round(Ncount, digits=2),"%"))
  summary.df <- addRow(summary.df, "GC count", paste(round(GCcount, digits=2),"%"))
  summary.df <- addRow(summary.df, "Mean coverage (primary)", round(meanCov, digits=2))
  
  rownames(summary.df) <- summary.df[,1]
  summary.df <- summary.df[,-1]
  return(summary.df)
}

summary.df <- cbind(collateMappingCharacteristics(backgroundUniverse, unmappedReads), 
                    collateMappingCharacteristics(offtargetUniverse),
                    collateMappingCharacteristics(targetproximalUniverse),
                    collateMappingCharacteristics(ontargetUniverse))
summary.df <- summary.df[, -c(2,4,6,8)]
summary.df[summary.df == "NaN"] <- ""


row.names(summary.df)[5]<- paste0(row.names(summary.df)[5], footnote_marker_symbol(1, "html"))
row.names(summary.df)[6]<- paste0(row.names(summary.df)[6], footnote_marker_symbol(2, "html"))
row.names(summary.df)[13]<- paste0(row.names(summary.df)[13], footnote_marker_symbol(3, "html"))
row.names(summary.df)[16]<- paste0(row.names(summary.df)[16], footnote_marker_symbol(4, "html"))
row.names(summary.df)[17]<- paste0(row.names(summary.df)[17], footnote_marker_symbol(5, "html"))

kable(summary.df, format="html", col.names=rep(" ", ncol(summary.df)), caption="Table summarising global mapping characteristics ranked by on-target, target-flanking and off-target", booktabs=TRUE, table.envir='table*', linesep="", escape = FALSE)  %>%
  add_header_above(c(" ", "Background"=1,"Off-Target"=1,"Target-flanking"=1,"On-Target"=1)) %>%
  kable_styling(c("striped", "condensed")) %>%
  pack_rows("Nucleotides mapped", 4, 7) %>%
  pack_rows("Sequence length characteristics (nt)", 8, 9) %>%
  pack_rows("Sequence quality characteristics (phred Qval)", 10, 12) %>%
  pack_rows("Reference genome characteristics", 13, 17) %>%
  footnote(symbol=c("fastq bases are calculated from the qwidth field of the mapped sequences and from the sequence length of unmapped sequences","clipped mapping calculated from CIGARquery coordinates", "standard workflow attempts to remove the mitochondrial chromosome and other accessory chromosomes", "The GC content is calculated as % of GC at positions where nucleotide is A/C/G/T", "depth of coverage based only on primary mapping reads"), symbol_title="please note: ", footnote_as_chunk = TRUE)


```


The next step in the analysis involves looking for the mapping characteristics for each of the targets specified within the BAM file. For brevity, only the most salient metrics are reported here (values such as the number of reads, the number of bases and mapping qualities), there are other values within the data (please check the **`brRes`** object).

```{r, echo=FALSE, results="asis", eval=TRUE}
bygene <- cbind(names(ontargetUniverse), as.character(seqnames(ontargetUniverse)), scales::comma_format()(ontargetUniverse$rstart), scales::comma_format()(ontargetUniverse$basesstart), scales::comma_format()(round(ontargetUniverse$meanreadlen, digits=2)), round(ontargetUniverse$readq, digits=2), round(ontargetUniverse$mapq, digits=2), round(ontargetUniverse$dmean, digits=2), round(ontargetUniverse$strandp / ontargetUniverse$rstart*100, digits=2))
colnames(bygene) <- seq(1, ncol(bygene))

colnames(bygene)[1]<- paste0("Target Gene")
colnames(bygene)[2]<- paste0("Chr.")
colnames(bygene)[3]<- paste0("Read count", footnote_marker_symbol(1, "html"))
colnames(bygene)[4]<- paste0("Bases", footnote_marker_symbol(2, "html"))
colnames(bygene)[5]<- paste0("Mean readLength")
colnames(bygene)[6]<- paste0("Mean readQuality")
colnames(bygene)[7]<- paste0("Mean mapQuality")
colnames(bygene)[8]<- paste0("Mean coverage")
colnames(bygene)[9]<- paste0("Reads on FWD(%)", footnote_marker_symbol(3, "html"))

kable(bygene, format="html", caption="Table summarising target mapping for pre-defined regions of interest", booktabs=TRUE, table.envir='table*', linesep="", escape = FALSE)  %>%
  kable_styling(c("striped", "condensed")) %>%
  footnote(symbol=c("reads are counted as all sequence reads that originate within the defined BED target region", "bases are counted as sum of nucleotides from reads that originate within target region; some of these bases may overlap flanking region", "reads are assessed for strand of mapping; here reads on + strand are summarised as percentage of all"), symbol_title="please note: ", footnote_as_chunk = TRUE)

```





```{r targetGeneDepths, echo=FALSE}
colMax=4
suppressWarnings(posMatrix <- matrix(gtools:::mixedsort(names(br)), ncol=colMax, byrow=TRUE))
  # data may be recycled ... remove duplicate values ...
posMatrix[which(duplicated(posMatrix[seq(nrow(posMatrix) * ncol(posMatrix))]))]<-NA

plotLegend <- paste0("t::",gtools:::mixedsort(names(br)))
plotCols <- ceiling(length(plotLegend) / colMax)
legendDF <- data.frame(x=Inf, y=Inf, 
                         lab=plotLegend, 
                         row=unlist(lapply(1:plotCols, rep, times=colMax))[1:length(plotLegend)], 
                         col=rep(seq(1, colMax), length.out=length(plotLegend)))

# add row and column data to aggregatedGR
aggregatedGR$row <- unlist(lapply(aggregatedGR$gene, function(x) { which(posMatrix==x, arr.ind=TRUE)[[1]] }))
aggregatedGR$col <- unlist(lapply(aggregatedGR$gene, function(x) { which(posMatrix==x, arr.ind=TRUE)[[2]] }))
aggregatedGR$rev_cov <- aggregatedGR$binned_cov - aggregatedGR$fwd_cov


singlePlot <- function(geneName, covData, delta=0) {
  delta=min(delta, target_proximity)
  covData <- as.data.frame(covData)
  covData <- covData[which(covData$gene==geneName),]
  offset <- covData[covData$pos==1,]$start
  ggplot(covData)+
    geom_hline(yintercept=(wga.cov * offtarget_level), colour="#E69F00") +
    geom_line(aes(x=start,y=binned_cov), size=0.5, colour=brewer.pal(6, "Paired")[2])+
    xlab(paste("Position on chromosome",unique(covData$seqnames))) + 
    ylab("Depth of Coverage (X)") + 
    labs(title=paste("Plot showing depth of coverage vs position for target", geneName)) + 
    geom_vline(xintercept=(offset+target_proximity), colour="red", alpha=0.4) +
    geom_vline(xintercept=(offset+(max(covData$pos)-target_proximity)), colour="red", alpha=0.4) +
    scale_x_continuous(limits = c(offset+delta, offset+max(covData$pos)-delta))
}

```


```{r, warning=FALSE}
singlePlot("C9orf72", aggregatedGR)

singlePlot("C9orf72", aggregatedGR, delta=22500)
```



```{r, echo=FALSE}
strandedPlot <- function(geneName, covData, delta=0) {
  delta=min(delta, target_proximity)
  covData <- as.data.frame(covData)
  covData <- covData[which(covData$gene==geneName),]
  offset <- covData[covData$pos==1,]$start
  mdata <- melt(covData[,c("gene", "start", "fwd_cov", "rev_cov")], id.vars=c("gene", "start"))
  ggplot(mdata, aes(start, value)) +
        geom_hline(yintercept=(wga.cov * offtarget_level), colour="#E69F00") +
    geom_area(aes(fill=variable))  +
    xlab(paste("Position on chromosome",unique(covData$seqnames))) + 
    ylab("Depth of Coverage (X)") + 
    labs(title=paste("Plot showing depth of coverage vs position for target", geneName)) + 
    geom_vline(xintercept=(offset+target_proximity), colour="red", alpha=0.4) +
    geom_vline(xintercept=(offset+(max(covData$pos)-target_proximity)), colour="red", alpha=0.4) +
    scale_x_continuous(limits = c(offset+delta, offset+max(covData$pos)-delta)) +
    scale_fill_manual(values=c(brewer.pal(5, "Paired")[1], brewer.pal(5, "Paired")[2]),
                      name="Strand mapped",
                         breaks=c("fwd_cov", "rev_cov"),
                         labels=c("Forward", "Reverse"))

}
```


```{r, warning=FALSE}
strandedPlot("C9orf72", aggregatedGR, delta=12500)
```





```{r aggregatePlot, echo=FALSE, warning=FALSE}
plotCoverageMegablock <- function(covData) {
  covData$start <- (as.numeric(covData$start))/1000
  suppressWarnings(megadepthplot <- ggplot(covData, aes(pos, binned_cov)) + 
                     geom_hline(yintercept=(wga.cov * offtarget_level), colour="#E69F00") +
                     geom_line(colour=brewer.pal(6, "Paired")[2]) + 
                     facet_grid(rows = vars(row), cols=vars(col)) + theme(axis.text.x = element_text(angle = 90, hjust = 1), strip.text.y = element_blank(), strip.text.x = element_blank()) + xlab("Position across target region (kb)") + ylab("Depth of Coverage (X)") + labs(title="Plot showing depth of coverage vs position for target regions") + geom_text(aes(x,y,label=lab), data=legendDF, vjust=1, hjust=1, size=3.5) + theme(plot.title = element_text(size=11)))
  return(megadepthplot)
}

plotCoverageMegablock(as.data.frame(aggregatedGR))

```



```{r offTargetByDepth, echo=FALSE}

targetMap <- data.frame(chromosome=gtools:::mixedsort(levels(seqnames(backgroundUniverse))), stringsAsFactors=FALSE)
targetMap <- cbind(targetMap, offtarget=unlist(lapply(targetMap$chromosome, function(x) { 
  sum(offtargetUniverse[which(seqnames(offtargetUniverse)==x)]$basesstart) } )))
targetMap <- cbind(targetMap, background=unlist(lapply(targetMap$chromosome, function(x) {   
  sum(backgroundUniverse[which(seqnames(backgroundUniverse)==x)]$basesstart) } )))
targetMap <- cbind(targetMap, ontarget=unlist(lapply(targetMap$chromosome, function(x) {   
  sum(ontargetUniverse[which(seqnames(ontargetUniverse)==x)]$basesstart) } )))
targetMap[is.na(targetMap)] <- 0
#targetMap
targetMelt <- melt(targetMap)
targetMelt$variable <- factor(as.character(targetMelt$variable), c("background", "ontarget", "offtarget"))
targetMelt$chromosome <- factor(targetMelt$chromosome, gtools:::mixedsort(unique(targetMelt$chromosome)))

ggplot(targetMelt, aes(chromosome, value)) + geom_col(aes(fill=variable)) + scale_y_continuous(labels = comma) + ylab("Number of bases (nt)") + labs(title="Barchart showing number of references bases assigned as ontarget,\nofftarget or background") + scale_fill_brewer(direction=-1, palette="Spectral")
# coord_cartesian(ylim =c(0,1000000))
```


# Reproducible research - produce your own report

This report has been created using **`Rmarkdown`**, publicly available **`R`** packages, and the \LaTeX document typesetting software for reproducibility. For clarity the **`R`** packages used, and their versions, are listed below.

\fontsize{8}{12}

```{r sessionInfo, eval=TRUE, echo=FALSE, comment=NA}
utils:::print.sessionInfo(sessionInfo()[-7], locale=FALSE)
```

\fontsize{10}{14}

It is also worth recording the versions of the software that have been used for the analysis.

\fontsize{8}{12}

```{r, engine='bash', echo=FALSE, comment=NA}
conda list "samtools|minimap2|snakemake|rstudio|seqtk"
```

\fontsize{10}{14}

`r slurpContent("Static/TutorialPostamble.md")`

\pagebreak


# References and citations
